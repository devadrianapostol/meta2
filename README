
  Meta-II
  =======


* Introduction

This is a simple implementation of "Meta-II", the compiler-compiler
designed by Val Schorre and presented in [1]. This variant generates C
instead of assembly code for the Meta II virtual machine, as in the
original version. I first tried to keep the intermediate stage and
have a Meta-II description for translating the pseudo-assembly to C,
but quickly hit the limitations of Meta-II itself (Meta-II
descriptions are free-format, the pseudo-assembler is not - it needs
positional information to distinguish between labels and operators).


* Building

To build the translator, you will need gcc(1), make(3) and bash(1).
Enter

  make bootstrap

to generate the initial "bootstrapping" compiler called "meta2" from
the pre-generated sources in the "bootstrap" directory. Once this has
been done, running

  make

will from now on rebuild the "meta2" binary with whatever changes you
made to the sources ("meta2.meta2" or "meta2.h"), using the bootstrap
compiler.

To force a rebuild of the compiler with itself and compare the output
of the new compiler with the source of the current one, enter

  make check

This also does a trivial check for a simple expression parser (see
"simple.meta2").


* Installation

To install the program in your system, enter

  make install

This will install the bootstrap compiler and the C header-file needed
for parsers generated by "meta2". See below for more information about
making "snapshots" to generate a reproducible bootstrapping compiler.

Note that it is not necessary to perform an installation - you can run
the program from the build-directory if you prefer.

The default installation prefix is "/usr/local", with files being
installed in "$PREFIX/bin" and "$PREFIX/include". You can override the
installation prefix by giving "PREFIX=<prefix>" to the make(3)
command, or edit "Makefile" accordingly:

  make PREFIX=/home/felix install

A script named "meta2c" is also available and compiles a parser
description directly into C, an object file or an executable (the
default is to generate an executable).

There is an emacs mode for .meta2 files in "misc/meta2-mode.el" which
provides some syntax highlighting. To install it, put "meta2-mode.el"
somewhere into your load path and evaluate

  (require 'meta2-mode)
  (add-to-list 'auto-mode-alist '("\\.meta2\\'" . meta2-mode))


* Usage

Every parser derived from a syntax description (either by using
"meta2c" or by invoking "meta2" and compiling the resulting C file by
hand) will read and write from standard-input and standard-output,
respectively, and understands the following command-line options:

  -h

     Show usage information and exit.

  -f 

     Flushes buffered output after every single output operation,
     specifically after every part of an ".OUT" command.

  -t

     Enable "trace" mode, which writes the name of each invoked
     syntax equation, the call-depth and a fragment of the current
     parse position to standard error.

  -q

     Enable "double-quote" mode. The ".STRING" command accepts strings
     delimited by double quotes ("...") in addition to the usual '...'
     strings normally accepted in Meta-II. In this mode strings are
     always written with double-quote delimiters. "-q" is required
     when generating a parser from "meta2.meta2".

  -b

     Do not skip whitespace when looking for the next match. The default
     is to skip any whitespace before matching.

  -i

     Enable "case-insensitive" mode. When matching literal strings,
     differences in case are allowed. The default mode is to match
     case-sensitively.

  -v

     Writes the "fingerprint" of this executable to standard output.
     This is the same as the git(1) commit ID of the sources used To
     create this version of the "meta2". This option is only available
     in parsers created via a "snapshot" (see below).

  -g

     Writes the "genealogy" of this executable to standard output.
     This is a list of the fingerprints of all versions that where
     used to create this version of the "meta2". This options is also
     only available in "snapshot" binaries.

The C code generated from the syntax description can be compiled like
any other C program, as long as the "meta2.h" include file is in the
include path. If you don't want to install the files in your system,
pass "-I." to the C compiler when compiling a translated
syntax-description.


* Reproducibility

In this implementation of Meta-II an attempt is made to generate fully
self-contained and reproducible executables and in particular allow
complete regeneration of a version of the parser-generator from all
its complete list of ancestors. Once a variant of the "meta2" program
is expected to be working correctly, a "snapshot" can be taken by
entering

  make snapshot

This will combine the C file generated from "meta2.meta2", the current
"meta2.h" header file, the version of the "meta2" executable and all
its ancestors used to generate this C file and the current HEAD commit
ID of git(1) repository in which the build takes place and create a
bootstrap version of the source and binary in the "bootstrap"
directory. The working directory must not contain any uncommitted
changes.  Also, "make check" is run before actually taking the
snapshot.


* Extensions

1. Delimited strings parsed using the ".STRING" command may contain
   backslash-sequences which will be written unchanged when given to
   ".OUT" (as in ".STRING .OUT(*)").

2. "<OUTPUT ...>" may be used as an alternative to ".OUT(OUTPUT ...)"
   with the output starting at column 1 (as in ".LABEL").

3. ";" may be used as alternative to ".,".

4. "|" may be used as alternative to "/".

5. ".NUMBER" accepts floating point numbers, optionally with scientific
   notation. The number-syntax accepted corresponds to the following
   Meta-II description:

   DIGIT = '0' / '1' / '2' / '3' / '4' / '5' / '6' / '7' / '8' / '9'
   NUMBER = $DIGIT ('.' $DIGIT / .EMPTY) 
   	    (('e' / 'E') ('+' / '-' / .EMPTY) $DIGIT / .EMPTY) .,

6. ".LENGTH <n>" matches a fixed number of characters in the input,
   (whitespace is not skipped). This can only fail if the remaining
   input has less than <n> characters.

7. If a literal match ('...') begins with whitespace, then whitespace
   will not be skipped before attempting the match.


* Implementation notes

The generated parsers read input all at once, so very large files will
be completely held in memory during parsing.

It is possible to embed a generated parser in a C program. If you
compile the code produced by "meta2" with "-DEMBED", no "main()"
function will be generated. You invoke the parser by calling the
"start()" function which will return 1 if the parse succeeded and 0 if
it failed. Error messages will always be written to the standard error
stream. The input-buffer is filled by either calling "read_input()",
which reads input from the standard input stream or by invoking

  input(char *start, char *end)

where "start" points to the start of the input and "end" points to the
location past the last character to be parsed. Before setting the
input and calling "start", you should invoke

  initialize(int argc, char *argv[])

which initializes the parser and parses command line arguments (the
same that are accepted by the "meta2" program and standalone parsers
generated by it).


* History

This implementation of Meta-II was generated by a quick-and-dirty
translation of the pseudo-assembler code for the original Meta-II
implementation, which can be found at [4], together with an excellent
tutorial.

Other interesting implementations of Meta-II are available at [2] and
[3].


* Contact information

For questions and suggestions, write to

  felix@call-with-current-continuation.org


* References

[1] http://www.ibm-1401.info/Meta-II-schorre.pdf

[2] https://github.com/impeachgod/meta

[3] https://github.com/robertfeldt/meta_compile

[4] http://www.bayfronttechnologies.com/metaii.html
